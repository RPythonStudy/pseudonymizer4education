---
title: "Pseudonymizer4education"
description: "판독보고서 등 의료정보의 가명화 예시 프로그램"
author: "BenKorea"
date: "2025-06-20"
date-modified: last-modified
---

## 파일명의 가명화

- EMR로부터 추출된 자료는 파일명에 환자식별정보가 포함될 수도 있습니다.
- 아래는 파일명이 환자 등록번호로 구성되어 있다고 가정하고, 이를 가명화하는 예시 프로그램입니다.

### 파일 읽어오기

- 이 프로젝트는 data/raw 디렉토리에 에시 판독보고서가 들어 있다고 가정하고 있습니다. 하지만 git 버전관리에서는 제외시켜 두었기 때문에 github에서 프로젝트를 다운로드 하더라도 다운로드 되지 않습니다.
- 연구회에서 분석목적으로 보유한 예시 파일들이 data/raw에 복사된 경우라면 아래과 같이 진행이 가능합니다.


### 가명화 패키지

- 이 프로젝트에서는 가명화 방식으로 가역적이며 일관성을 보장하는 가명화(reversible deterministic pseudonymization)를 채택하였습니다.
- 이를 위해 원본 형식을 유지하는 형식보존암호화(format-preserving encryption)를 적용하였으며, 미국 NIST에서 권장하는 FF1 알고리즘을 구현한 pyffx 파이썬 패키지를 활용하였습니다.
- pyffx는 파이썬의 패키지로만 구할 수 있어 reticulate 패키지를 설치한 후 파이썬 모듈을 감싸는 방식으로 import 하였습니다.
- reticulate 패키지에게 파이썬 패키지를 인식시킬려면 이 프로젝트 폴더에 파이썬의 가상환경을 활성화 시키고 pyffx 패키지를 설치하는 방식이 가장 추천됩니다.
- 파이썬 가상환경의 설치는 연구회 웹사이트 해당부분을 참고하시길 바랍니다. (https://rpythonstudy.github.io/website/posts/Python/install/VSCode_setup.html)

```{r}
#| label: excel_column_pseudonymizer

excel_column_pseudonymizer <- function(
  excel_path,
  pseudonym_rules = list(),
  env_file = ".env",
  key_var = "PSEUDONYM_KEY"
) {
  if (!requireNamespace("readxl", quietly = TRUE)) install.packages("readxl")
  if (!requireNamespace("writexl", quietly = TRUE)) install.packages("writexl")
  if (!requireNamespace("dotenv", quietly = TRUE)) install.packages("dotenv")
  library(readxl)
  library(writexl)
  library(reticulate)
  library(dotenv)

  dotenv::load_dot_env(env_file)
  key_string <- Sys.getenv(key_var)
  if (key_string == "") stop("가명화 키가 환경변수에서 읽히지 않았습니다.")

  pyffx <- import("pyffx")
  KEY <- r_to_py(charToRaw(key_string))

  df <- readxl::read_excel(excel_path)

  pseudonym_columns <- names(pseudonym_rules)
  pseudonym_columns <- pseudonym_columns[pseudonym_columns %in% names(df)]
  if (length(pseudonym_columns) == 0) {
    stop("pseudonym_rules에 지정된 컬럼이 데이터에 없습니다.")
  }

  pseudo_data <- list()
  pseudo_colnames <- paste0("P_", pseudonym_columns)

  for (col in pseudonym_columns) {
    orig <- df[[col]]
    rule <- pseudonym_rules[[col]]
    if (!is.null(rule$alphabet)) {
      alphabet <- rule$alphabet
    } else {
      vals <- as.character(orig)
      vals[is.na(vals)] <- ""
      chars <- unique(unlist(strsplit(paste(vals, collapse = ""), split = "")))
      alphabet <- paste(chars, collapse = "")
      message(sprintf("컬럼 [%s]의 alphabet을 자동 추출했습니다: [%s]", col, alphabet))
    }

    vals <- as.character(orig)
    vals[is.na(vals)] <- ""
    lengths <- nchar(vals, type = "chars")
    max_len <- max(lengths, na.rm = TRUE)

    pad_char <- substr(alphabet, 1, 1)
    n <- nrow(df)
    pseudo_values <- vapply(seq_len(n), function(i) {
      x <- orig[i]
      if (is.na(x)) return(NA_character_)
      x_str <- as.character(x)
      len <- nchar(x_str, type = "chars")
      if (len == 0 || is.na(len)) return(NA_character_)
      if (len < max_len) {
        pad_n <- max_len - len
        pad_str <- paste(rep(pad_char, pad_n), collapse = "")
        pad_x <- paste0(x_str, pad_str)
      } else if (len > max_len) {
        pad_x <- substr(x_str, 1, max_len)
      } else {
        pad_x <- x_str
      }
      cipher <- pyffx$String(KEY, alphabet = alphabet, length = max_len)
      cipher$encrypt(pad_x)
    }, FUN.VALUE = character(1), USE.NAMES = FALSE)
    pseudo_data[[col]] <- pseudo_values
  }

  orig_col_names <- names(df)
  col_idxs <- match(pseudonym_columns, orig_col_names)
  df_reduced <- df[ , !orig_col_names %in% pseudonym_columns, drop = FALSE]

  final_col_names <- names(df_reduced)
  for (i in seq_along(pseudonym_columns)) {
    col <- pseudonym_columns[i]
    pseudo_col <- paste0("P_", col)
    idx <- col_idxs[i]
    before <- if (idx == 1) character(0) else final_col_names[1:(idx - 1)]
    after  <- if (idx > length(final_col_names)) character(0) else final_col_names[idx:length(final_col_names)]
    final_col_names <- c(before, pseudo_col, after)
  }

  for (i in seq_along(pseudonym_columns)) {
    df_reduced[[paste0("P_", pseudonym_columns[i])]] <- pseudo_data[[pseudonym_columns[i]]]
  }

  df_final <- df_reduced[, final_col_names, drop = FALSE]
  if (!is.data.frame(df_final)) df_final <- as.data.frame(df_final)
  rownames(df_final) <- NULL

  # ---------- 결과 파일 저장 ----------
  # 결과 저장 폴더 생성
  output_dir <- "data/pseudonymized"
  if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)

  # 파일명 생성 (원본파일명 앞에 'P_' 붙임, 확장자 유지)
  in_fname <- basename(excel_path)
  out_fname <- paste0("P_", in_fname)
  out_path <- file.path(output_dir, out_fname)

  writexl::write_xlsx(df_final, out_path)
  message(sprintf("가명화 결과를 [%s]에 저장했습니다.", out_path))

  return(df_final)
}


```

```{r}
#| label: pseudonymize_result

# 1. '등록번호'는 숫자만, '환자명'은 알파벳 자동 추출(혹은 직접 지정)
rules <- list(
  등록번호 = list(alphabet = "0123456789"),
  성명   = list(), # alphabet 생략시 자동 추출
  제1판독의   = list(), # alphabet 생략시 자동 추출
  제2판독의   = list() # alphabet 생략시 자동 추출  
)
df_pseudo <- excel_column_pseudonymizer(
  "data/raw/sample.xls",
  pseudonym_rules = rules
)
head(df_pseudo)


```



```{r the_end}

```
